# -*- coding: utf-8 -*-
"""car-logo-classification (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11DCfq3S9uAYvkutZBfXtUj0xfoMUxdIO

# **1. Imports and Dependencies:**
"""

import cv2
import numpy as np
from tensorflow.keras import layers, models, backend, utils, regularizers, callbacks
from tensorflow.keras.applications import InceptionResNetV2
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.initializers import HeNormal
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn import metrics
import tensorflow as tf
import random
import os
import shutil
import glob
import seaborn as sns

"""# **2. Setting Up Training, Validation and Testing Datasets:**"""

train_val_dataset_path = "/kaggle/input/car-brand-logos/Car_Brand_Logos/Train"
test_dataset_path = "/kaggle/input/car-brand-logos/Car_Brand_Logos/Test"
train_path = "/kaggle/working/train"
val_path = "/kaggle/working/val"
test_path = "/kaggle/working/test"

os.makedirs(train_path, exist_ok=True)
os.makedirs(val_path, exist_ok=True)
os.makedirs(test_path, exist_ok=True)

car_brands = os.listdir(train_val_dataset_path)

for brand in car_brands:
    brand_train_path = os.path.join(train_val_dataset_path, brand)
    brand_val_path = os.path.join(val_path, brand)
    os.makedirs(os.path.join(train_path, brand), exist_ok=True)
    os.makedirs(brand_val_path, exist_ok=True)
    images = os.listdir(brand_train_path)
    np.random.shuffle(images)
    train_images = images[:int(0.8*len(images))]  # 80% for training
    val_images = images[int(0.8*len(images)):]    # 20% for validation
    for img in train_images:
        shutil.copy(os.path.join(brand_train_path, img), os.path.join(train_path, brand))
    for img in val_images:
        shutil.copy(os.path.join(brand_train_path, img), os.path.join(brand_val_path, img))

shutil.copytree(test_dataset_path, test_path, dirs_exist_ok=True)

print("Dataset forming is completed!")

train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.1,
    height_shift_range=0.1,
    shear_range=0.1,
    zoom_range=0.1,
    horizontal_flip=True,
    fill_mode='nearest'
)

val_test_datagen = ImageDataGenerator(rescale=1./255)


train_generator = train_datagen.flow_from_directory(
    train_path,
    target_size=(224, 224),
    batch_size=64,
    class_mode='categorical'
)

val_generator = val_test_datagen.flow_from_directory(
    val_path,
    target_size=(224, 224),
    batch_size=64,
    class_mode='categorical'
)

test_generator = val_test_datagen.flow_from_directory(
    test_path,
    target_size=(224, 224),
    batch_size=64,
    class_mode='categorical'
)

# Generators
print(train_generator.class_indices.keys())
print(val_generator.class_indices.keys())
print(test_generator.class_indices.keys())

def plot_random_samples(generator, title):
    plt.figure(figsize=(15, 5))
    plt.suptitle(title)
    for i in range(5):
        plt.subplot(1, 5, i+1)
        batch = next(generator)
        image = batch[0][random.randint(0, len(batch[0])-1)]  # Select a random image from the batch
        plt.imshow(image)
        plt.axis('off')
    plt.show()


plot_random_samples(train_generator, "Random Samples from Train Dataset")
plot_random_samples(val_generator, "Random Samples from Validation Dataset")
plot_random_samples(test_generator, "Random Samples from Test Dataset")

"""# **3. Defining the CNN Model:**"""

model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='swish', padding='same', input_shape=(224, 224, 3), kernel_initializer=HeNormal()),
    layers.Conv2D(32, (3, 3), activation='swish', padding='same', kernel_initializer=HeNormal()),
    layers.MaxPooling2D((2, 2)),
    layers.BatchNormalization(),
    layers.Dropout(0.3),

    layers.Conv2D(64, (3, 3), activation='swish', padding='same', kernel_initializer=HeNormal()),
    layers.Conv2D(64, (3, 3), activation='swish', padding='same', kernel_initializer=HeNormal()),
    layers.MaxPooling2D((2, 2)),
    layers.BatchNormalization(),
    layers.Dropout(0.3),

    layers.Conv2D(128, (3, 3), activation='swish', padding='same', kernel_initializer=HeNormal()),
    layers.Conv2D(128, (3, 3), activation='swish', padding='same', kernel_initializer=HeNormal()),
    layers.MaxPooling2D((2, 2)),
    layers.BatchNormalization(),
    layers.Dropout(0.4),

    layers.Conv2D(256, (3, 3), activation='swish', padding='same', kernel_initializer=HeNormal()),
    layers.Conv2D(256, (3, 3), activation='swish', padding='same', kernel_initializer=HeNormal()),
    layers.MaxPooling2D((2, 2)),
    layers.BatchNormalization(),
    layers.Dropout(0.4),

    layers.Flatten(),
    layers.Dense(512, activation='swish', kernel_regularizer=regularizers.l2(0.001), kernel_initializer=HeNormal()),
    layers.Dropout(0.5),
    layers.BatchNormalization(),

    layers.Dense(512, activation='swish', kernel_regularizer=regularizers.l2(0.001), kernel_initializer=HeNormal()),
    layers.Dropout(0.5),
    layers.BatchNormalization(),

    layers.Dense(8, activation='softmax')
])

model.compile(optimizer= Adam(learning_rate=0.001),
              loss='categorical_crossentropy',
              metrics=['accuracy'])


model.summary()

"""# **4. Training The CNN Model:**"""

history = model.fit(
    train_generator,
    steps_per_epoch=train_generator.samples // train_generator.batch_size,
    validation_data=val_generator,
    validation_steps=val_generator.samples // val_generator.batch_size,
    epochs=200
)

# Evaluate model
loss, accuracy = model.evaluate(test_generator)
print(f"Test Accuracy: {accuracy * 100:.2f}%")

"""# **5. Loss and Accuracy Graphs for Training and Validation Data:**"""

plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(loc='upper left')
plt.grid(True)

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(loc='upper left')
plt.grid(True)

plt.tight_layout()
plt.show()

"""# **6. Testing Results and Evaluation Metrics:**"""

#Testing:
loss, accuracy = model.evaluate(test_generator)
print(f"Test Accuracy: {accuracy * 100:.2f}%")
print(f"Test Loss: {loss:.4f}")

predictions = model.predict(test_generator)
predicted_classes = np.argmax(predictions, axis=1)
true_classes = test_generator.classes
class_labels = list(test_generator.class_indices.keys())

report = metrics.classification_report(true_classes, predicted_classes, target_names=class_labels)
print(report)

cm = metrics.confusion_matrix(true_classes, predicted_classes)
plt.figure(figsize=(12, 12))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_labels, yticklabels=class_labels)
plt.xlabel('Predicted')
plt.ylabel('True')
plt.show()

precision = dict()
recall = dict()
average_precision = dict()

for i in range(len(class_labels)):
    precision[i], recall[i], _ = metrics.precision_recall_curve((true_classes == i).astype(int), predictions[:, i])
    average_precision[i] = metrics.average_precision_score((true_classes == i).astype(int), predictions[:, i])

precision["micro"], recall["micro"], _ = metrics.precision_recall_curve(
    utils.to_categorical(true_classes).ravel(), predictions.ravel()
)
average_precision["micro"] = metrics.average_precision_score(utils.to_categorical(true_classes), predictions, average="micro")
plt.figure(figsize=(8, 6))
plt.step(recall["micro"], precision["micro"], color="b", alpha=0.2, where="post")
plt.fill_between(recall["micro"], precision["micro"], alpha=0.2, color="b")

for i in range(len(class_labels)):
    plt.step(
        recall[i], precision[i], where="post", label=f"Class {class_labels[i]} (AP = {average_precision[i]:0.2f})"
    )
plt.xlabel("Recall")
plt.ylabel("Precision")
plt.ylim([0.0, 1.05])
plt.xlim([0.0, 1.0])
plt.title("Precision-Recall curve")
plt.legend(loc="lower right")
plt.show()

"""# **7. Testing The CNN on Samples from Test Dataset:**"""

def plot_predictions(generator, model, num_images=10):
    x, y = next(generator)
    predictions = model.predict(x)
    predicted_classes = np.argmax(predictions, axis=1)
    true_classes = np.argmax(y, axis=1)
    plt.figure(figsize=(20, 10))
    for i in range(num_images):
        plt.subplot(2, num_images // 2, i + 1)
        plt.imshow(x[i])
        plt.title(f"True: {class_labels[true_classes[i]]}\nPred: {class_labels[predicted_classes[i]]}")
        plt.axis('off')
    plt.show()

plot_predictions(test_generator, model)

"""# **8. Testing The CNN on 4 Random Samples Outside all Datasets (Training, Validation, Testing):**"""

# Testing On Individual Car Logos Outside dataset: Hyundai
image_path = "/kaggle/input/testing-carlogos/hyundaiTest.jpg"
image = cv2.imread(image_path)
image = cv2.resize(image, (224, 224))
image = image / 255.0

image = np.expand_dims(image, axis=0)
predictions = model.predict(image)
predicted_class = np.argmax(predictions)

class_labels = list(train_generator.class_indices.keys())
predicted_label = class_labels[predicted_class]

plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
plt.title('Predicted Class: ' + predicted_label)
plt.axis('off')
plt.show()

print("Predicted Class:", predicted_label)
print("Predicted Probabilities:", predictions)

# Testing On Individual Car Logos Outside dataset: Toyota
image_path = "/kaggle/input/testing-carlogos/toyotaTest.jpg"
image = cv2.imread(image_path)
image = cv2.resize(image, (224, 224))
image = image / 255.0

image = np.expand_dims(image, axis=0)
predictions = model.predict(image)
predicted_class = np.argmax(predictions)

class_labels = list(train_generator.class_indices.keys())
predicted_label = class_labels[predicted_class]

plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
plt.title('Predicted Class: ' + predicted_label)
plt.axis('off')
plt.show()

print("Predicted Class:", predicted_label)
print("Predicted Probabilities:", predictions)

# Testing On Individual Car Logos Outside dataset: Volkswagen
image_path = "/kaggle/input/testing-carlogos/volkswagenTest.jpg"
image = cv2.imread(image_path)
image = cv2.resize(image, (224, 224))
image = image / 255.0

image = np.expand_dims(image, axis=0)
predictions = model.predict(image)
predicted_class = np.argmax(predictions)

class_labels = list(train_generator.class_indices.keys())
predicted_label = class_labels[predicted_class]

plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
plt.title('Predicted Class: ' + predicted_label)
plt.axis('off')
plt.show()

print("Predicted Class:", predicted_label)
print("Predicted Probabilities:", predictions)

# Testing On Individual Car Logos Outside dataset: Mercedes
image_path = "/kaggle/input/testing-carlogos/mercedesTest.jpg"
image = cv2.imread(image_path)
image = cv2.resize(image, (224, 224))
image = image / 255.0

image = np.expand_dims(image, axis=0)
predictions = model.predict(image)
predicted_class = np.argmax(predictions)

class_labels = list(train_generator.class_indices.keys())
predicted_label = class_labels[predicted_class]

plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
plt.title('Predicted Class: ' + predicted_label)
plt.axis('off')
plt.show()

print("Predicted Class:", predicted_label)
print("Predicted Probabilities:", predictions)